# æˆé•¿å¾½ç« æ¨¡å—æŠ€æœ¯æ–¹æ¡ˆ

## éœ€æ±‚æ¦‚è¿°

è®¾è®¡ä¸€ä¸ªå¯æ‰©å±•çš„å¾½ç« ç³»ç»Ÿï¼š
- **è‡ªå®šä¹‰å¾½ç« **ï¼šå›¾æ ‡ã€åç§°ã€æè¿°ã€ç­‰çº§
- **çµæ´»è§¦å‘æ¡ä»¶**ï¼šç´¯è®¡ç§¯åˆ†ã€è¿ç»­ç­¾åˆ°ã€å…‘æ¢æ¬¡æ•°ç­‰
- **å…³è”å¥–åŠ±**ï¼šè·å¾—å¾½ç« æ—¶å‘æ”¾é¢å¤–ç§¯åˆ†
- **å¾½ç« å±•ç¤º**ï¼šåœ¨å­©å­æ¡£æ¡ˆé¡µå±•ç¤º

---

## ä¸€ã€æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Badge Detection Engine                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  è§¦å‘äº‹ä»¶                    æ£€æµ‹å¼•æ“                   æˆäºˆæœåŠ¡   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ç§¯åˆ†å˜åŠ¨         â”‚â”€â”€â”€>â”‚                  â”‚â”€â”€â”€>â”‚ åˆ›å»ºè·å¾—è®°å½• â”‚ â”‚
â”‚  â”‚ å…‘æ¢å®Œæˆ         â”‚    â”‚  BadgeDetector   â”‚    â”‚ å‘æ”¾å¥–åŠ±ç§¯åˆ† â”‚ â”‚
â”‚  â”‚ ç­¾åˆ°å®Œæˆ         â”‚    â”‚                  â”‚    â”‚ å¼¹çª—é€šçŸ¥    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                  â”‚                               â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚                    â–¼             â–¼             â–¼                â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚              â”‚ç´¯è®¡ç§¯åˆ†   â”‚  â”‚è¿ç»­ç­¾åˆ°   â”‚  â”‚å…‘æ¢æ¬¡æ•°   â”‚          â”‚
â”‚              â”‚Evaluator â”‚  â”‚Evaluator â”‚  â”‚Evaluator â”‚          â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€æ•°æ®æ¨¡å‹è®¾è®¡

### 2.1 æ–°å¢æ•°æ®åº“è¡¨

```dart
// lib/core/database/tables.dart æ–°å¢

/// å¾½ç« å®šä¹‰è¡¨
class Badges extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();                    // å¾½ç« åç§°
  TextColumn get description => text().nullable()(); // æè¿°
  TextColumn get icon => text()();                   // å›¾æ ‡æ ‡è¯†
  IntColumn get level => integer().withDefault(const Constant(1))(); // ç­‰çº§

  // è§¦å‘æ¡ä»¶
  TextColumn get triggerType => text()();            // æ¡ä»¶ç±»å‹æšä¸¾
  IntColumn get triggerThreshold => integer()();     // é˜ˆå€¼
  TextColumn get triggerConfig => text().nullable()(); // æ‰©å±•é…ç½®(JSON)

  IntColumn get bonusPoints => integer().withDefault(const Constant(0))(); // å¥–åŠ±ç§¯åˆ†
  IntColumn get sortOrder => integer().withDefault(const Constant(0))();   // æ’åº
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  BoolColumn get isSystem => boolean().withDefault(const Constant(false))();
  BoolColumn get isDeleted => boolean().withDefault(const Constant(false))();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime().nullable()();
}

/// å¾½ç« è·å¾—è®°å½•è¡¨
class BadgeAcquisitions extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get childId => integer().references(Children, #id)();
  IntColumn get badgeId => integer().references(Badges, #id)();
  TextColumn get badgeSnapshot => text()();          // å¾½ç« å¿«ç…§(JSON)
  IntColumn get bonusPointsAwarded => integer()();   // å‘æ”¾çš„å¥–åŠ±ç§¯åˆ†
  IntColumn get pointRecordId => integer().nullable()(); // å…³è”ç§¯åˆ†æµæ°´
  IntColumn get triggerValue => integer().nullable()();  // è§¦å‘æ—¶çš„å®é™…å€¼
  TextColumn get note => text().nullable()();
  BoolColumn get isDeleted => boolean().withDefault(const Constant(false))();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime().nullable()();
}

/// ç­¾åˆ°è®°å½•è¡¨ï¼ˆæ”¯æŒè¿ç»­ç­¾åˆ°å¾½ç« ï¼‰
class CheckinRecords extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get childId => integer().references(Children, #id)();
  TextColumn get checkinDate => text()();            // ç­¾åˆ°æ—¥æœŸ YYYY-MM-DD
  IntColumn get streakDays => integer()();           // è¿ç»­å¤©æ•°
  IntColumn get pointRecordId => integer().nullable()();
  BoolColumn get isDeleted => boolean().withDefault(const Constant(false))();
  DateTimeColumn get createdAt => dateTime()();
}
```

### 2.2 è§¦å‘æ¡ä»¶ç±»å‹

| ç±»å‹ | æšä¸¾å€¼ | è¯´æ˜ | ç¤ºä¾‹ |
|------|--------|------|------|
| ç´¯è®¡ç§¯åˆ† | `total_points` | ç´¯è®¡è·å¾—ç§¯åˆ†è¾¾åˆ°é˜ˆå€¼ | ç´¯è®¡1000æ˜Ÿè·å¾—"æ˜Ÿå…‰ç’€ç’¨" |
| è¿ç»­ç­¾åˆ° | `consecutive_checkin` | è¿ç»­ç­¾åˆ°å¤©æ•°è¾¾åˆ°é˜ˆå€¼ | è¿ç»­7å¤©è·å¾—"åšæŒä¸€å‘¨" |
| å…‘æ¢æ¬¡æ•° | `exchange_count` | å…‘æ¢å•†å“æ¬¡æ•°è¾¾åˆ°é˜ˆå€¼ | å…‘æ¢10æ¬¡è·å¾—"è´­ç‰©è¾¾äºº" |
| å•æ¬¡ç§¯åˆ† | `points_earned_single` | å•æ¬¡è·å¾—ç§¯åˆ†è¾¾åˆ°é˜ˆå€¼ | å•æ¬¡50æ˜Ÿè·å¾—"å¤§æœ‰ä½œä¸º" |
| è‡ªå®šä¹‰ | `custom` | é¢„ç•™æ‰©å±• | - |

### 2.3 è§¦å‘æ¡ä»¶é…ç½® Schemaï¼ˆtriggerConfig JSON æ ¼å¼ï¼‰

```json
// ç´¯è®¡ç§¯åˆ†ç±»å‹
{
  "pointType": "all"  // all: æ‰€æœ‰ç§¯åˆ†, earned: ä»…è·å¾—çš„, spent: ä»…æ¶ˆè´¹çš„
}

// è¿ç»­ç­¾åˆ°ç±»å‹
{
  "allowMakeup": false,  // æ˜¯å¦å…è®¸è¡¥ç­¾
  "resetOnMiss": true    // æ–­ç­¾æ˜¯å¦é‡ç½®è¿ç»­å¤©æ•°
}

// å…‘æ¢æ¬¡æ•°ç±»å‹
{
  "categoryFilter": null,  // null: æ‰€æœ‰ç±»åˆ«, æˆ–æŒ‡å®šç±»åˆ«
  "minPrice": 0            // æœ€ä½å…‘æ¢ç§¯åˆ†é™åˆ¶
}

// å•æ¬¡è·å¾—ç§¯åˆ†ç±»å‹
{
  "ruleTypeFilter": null   // null: æ‰€æœ‰è§„åˆ™, æˆ–æŒ‡å®šè§„åˆ™ç±»å‹
}
```

---

## ä¸‰ã€é¢†åŸŸå®ä½“è®¾è®¡

### 3.1 å¾½ç« å®ä½“

```dart
// lib/features/badges/domain/entities/badge_entity.dart

/// å¾½ç« è§¦å‘æ¡ä»¶ç±»å‹æšä¸¾
enum BadgeTriggerType {
  totalPoints('total_points'),           // ç´¯è®¡è·å¾—ç§¯åˆ†
  consecutiveCheckin('consecutive_checkin'), // è¿ç»­ç­¾åˆ°
  exchangeCount('exchange_count'),       // å…‘æ¢æ¬¡æ•°
  pointsEarnedSingle('points_earned_single'), // å•æ¬¡ç§¯åˆ†
  custom('custom');                      // è‡ªå®šä¹‰

  final String value;
  const BadgeTriggerType(this.value);

  static BadgeTriggerType fromString(String value) {
    return BadgeTriggerType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => BadgeTriggerType.custom,
    );
  }
}

/// å¾½ç« é¢†åŸŸå®ä½“
@immutable
class BadgeEntity {
  final int id;
  final String name;
  final String? description;
  final String icon;
  final int level;
  final BadgeTriggerType triggerType;
  final int triggerThreshold;
  final Map<String, dynamic>? triggerConfig;
  final int bonusPoints;
  final int sortOrder;
  final bool isActive;
  final bool isSystem;
  final bool isDeleted;
  final DateTime createdAt;
  final DateTime? updatedAt;

  const BadgeEntity({...});

  /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆå¾½ç« 
  bool get isValid => isActive && !isDeleted;

  /// è·å–è§¦å‘æ¡ä»¶çš„æè¿°æ–‡æœ¬
  String get triggerDescription {
    switch (triggerType) {
      case BadgeTriggerType.totalPoints:
        return 'ç´¯è®¡è·å¾— $triggerThreshold é¢—æ˜Ÿæ˜Ÿ';
      case BadgeTriggerType.consecutiveCheckin:
        return 'è¿ç»­ç­¾åˆ° $triggerThreshold å¤©';
      case BadgeTriggerType.exchangeCount:
        return 'å…‘æ¢å•†å“ $triggerThreshold æ¬¡';
      case BadgeTriggerType.pointsEarnedSingle:
        return 'å•æ¬¡è·å¾— $triggerThreshold é¢—æ˜Ÿæ˜Ÿ';
      case BadgeTriggerType.custom:
        return description ?? 'å®Œæˆç‰¹å®šä»»åŠ¡';
    }
  }
}
```

### 3.2 å¾½ç« è·å¾—è®°å½•å®ä½“

```dart
// lib/features/badges/domain/entities/badge_acquisition_entity.dart

@immutable
class BadgeAcquisitionEntity {
  final int id;
  final int childId;
  final int badgeId;
  final String badgeSnapshot;
  final int bonusPointsAwarded;
  final int? pointRecordId;
  final int? triggerValue;
  final String? note;
  final bool isDeleted;
  final DateTime createdAt;
  final DateTime? updatedAt;

  const BadgeAcquisitionEntity({...});

  bool get hasBonusPoints => bonusPointsAwarded > 0;
}
```

---

## å››ã€è§¦å‘æ¡ä»¶å¼•æ“æ¶æ„

### 4.1 æ¡ä»¶è¯„ä¼°å™¨æ¥å£

```dart
// lib/features/badges/domain/evaluators/badge_condition_evaluator.dart

/// å¾½ç« æ¡ä»¶è¯„ä¼°ç»“æœ
class BadgeEvaluationResult {
  final bool isSatisfied;      // æ˜¯å¦æ»¡è¶³æ¡ä»¶
  final int currentValue;      // å½“å‰è¿›åº¦å€¼
  final int targetThreshold;   // ç›®æ ‡é˜ˆå€¼

  double get progress =>
      targetThreshold > 0 ? (currentValue / targetThreshold).clamp(0.0, 1.0) : 0.0;

  const BadgeEvaluationResult({...});
}

/// å¾½ç« æ¡ä»¶è¯„ä¼°å™¨æŠ½è±¡æ¥å£ï¼ˆç­–ç•¥æ¨¡å¼ï¼‰
abstract class IBadgeConditionEvaluator {
  BadgeTriggerType get supportedType;
  Future<BadgeEvaluationResult> evaluate(int childId, BadgeEntity badge);
}
```

### 4.2 å„ç±»å‹è¯„ä¼°å™¨å®ç°

```dart
// ç´¯è®¡ç§¯åˆ†è¯„ä¼°å™¨
class TotalPointsEvaluator implements IBadgeConditionEvaluator {
  final IPointRecordsRepository _pointRecordsRepository;

  @override
  BadgeTriggerType get supportedType => BadgeTriggerType.totalPoints;

  @override
  Future<BadgeEvaluationResult> evaluate(int childId, BadgeEntity badge) async {
    final stats = await _pointRecordsRepository.getStats(childId);
    final totalEarned = stats['earned'] ?? 0;
    return BadgeEvaluationResult(
      isSatisfied: totalEarned >= badge.triggerThreshold,
      currentValue: totalEarned,
      targetThreshold: badge.triggerThreshold,
    );
  }
}

// è¿ç»­ç­¾åˆ°è¯„ä¼°å™¨
class ConsecutiveCheckinEvaluator implements IBadgeConditionEvaluator {
  final ICheckinRepository _checkinRepository;

  @override
  BadgeTriggerType get supportedType => BadgeTriggerType.consecutiveCheckin;

  @override
  Future<BadgeEvaluationResult> evaluate(int childId, BadgeEntity badge) async {
    final currentStreak = await _checkinRepository.getCurrentStreak(childId);
    return BadgeEvaluationResult(
      isSatisfied: currentStreak >= badge.triggerThreshold,
      currentValue: currentStreak,
      targetThreshold: badge.triggerThreshold,
    );
  }
}

// å…‘æ¢æ¬¡æ•°è¯„ä¼°å™¨
class ExchangeCountEvaluator implements IBadgeConditionEvaluator {
  final IExchangeRepository _exchangeRepository;

  @override
  BadgeTriggerType get supportedType => BadgeTriggerType.exchangeCount;

  @override
  Future<BadgeEvaluationResult> evaluate(int childId, BadgeEntity badge) async {
    final exchangeCount = await _exchangeRepository.getExchangeCount(childId);
    return BadgeEvaluationResult(
      isSatisfied: exchangeCount >= badge.triggerThreshold,
      currentValue: exchangeCount,
      targetThreshold: badge.triggerThreshold,
    );
  }
}

// å•æ¬¡ç§¯åˆ†è¯„ä¼°å™¨
class SinglePointsEvaluator implements IBadgeConditionEvaluator {
  int? _currentSinglePoints;

  @override
  BadgeTriggerType get supportedType => BadgeTriggerType.pointsEarnedSingle;

  void setContext({required int singlePoints}) {
    _currentSinglePoints = singlePoints;
  }

  @override
  Future<BadgeEvaluationResult> evaluate(int childId, BadgeEntity badge) async {
    final points = _currentSinglePoints ?? 0;
    return BadgeEvaluationResult(
      isSatisfied: points >= badge.triggerThreshold,
      currentValue: points,
      targetThreshold: badge.triggerThreshold,
    );
  }
}
```

### 4.3 è¯„ä¼°å™¨å·¥å‚

```dart
// lib/features/badges/domain/evaluators/badge_evaluator_factory.dart

class BadgeEvaluatorFactory {
  final Map<BadgeTriggerType, IBadgeConditionEvaluator> _evaluators = {};

  void register(IBadgeConditionEvaluator evaluator) {
    _evaluators[evaluator.supportedType] = evaluator;
  }

  IBadgeConditionEvaluator? getEvaluator(BadgeTriggerType type) {
    return _evaluators[type];
  }

  bool supports(BadgeTriggerType type) => _evaluators.containsKey(type);
}
```

### 4.4 å¾½ç« æ£€æµ‹æœåŠ¡

```dart
// lib/features/badges/domain/services/badge_detection_service.dart

class PendingBadgeAward {
  final BadgeEntity badge;
  final int triggerValue;
  const PendingBadgeAward({required this.badge, required this.triggerValue});
}

class BadgeDetectionService {
  final IBadgeRepository _badgeRepository;
  final IBadgeAcquisitionRepository _acquisitionRepository;
  final BadgeEvaluatorFactory _evaluatorFactory;

  /// æ£€æµ‹å­©å­å¯è·å¾—çš„æ–°å¾½ç« 
  Future<List<PendingBadgeAward>> detectNewBadges(
    int childId, {
    List<BadgeTriggerType>? triggerTypes,
  }) async {
    final pendingAwards = <PendingBadgeAward>[];

    // 1. è·å–æ‰€æœ‰æœ‰æ•ˆå¾½ç« 
    final allBadges = await _badgeRepository.getActiveBadges();

    // 2. è·å–è¯¥å­©å­å·²è·å¾—çš„å¾½ç« IDé›†åˆ
    final acquiredBadgeIds = await _acquisitionRepository.getAcquiredBadgeIds(childId);

    // 3. ç­›é€‰å°šæœªè·å¾—ä¸”ç¬¦åˆè§¦å‘ç±»å‹çš„å¾½ç« 
    final candidateBadges = allBadges.where((badge) {
      final notAcquired = !acquiredBadgeIds.contains(badge.id);
      final typeMatch = triggerTypes == null || triggerTypes.contains(badge.triggerType);
      return notAcquired && typeMatch;
    }).toList();

    // 4. é€ä¸ªè¯„ä¼°
    for (final badge in candidateBadges) {
      final evaluator = _evaluatorFactory.getEvaluator(badge.triggerType);
      if (evaluator == null) continue;

      final result = await evaluator.evaluate(childId, badge);
      if (result.isSatisfied) {
        pendingAwards.add(PendingBadgeAward(
          badge: badge,
          triggerValue: result.currentValue,
        ));
      }
    }

    return pendingAwards;
  }
}
```

---

## äº”ã€å…³é”®ç”¨ä¾‹è®¾è®¡

### 5.1 ç”¨ä¾‹åˆ—è¡¨

| ç”¨ä¾‹ | èŒè´£ | è§¦å‘æ—¶æœº |
|------|------|----------|
| `CheckAndAwardBadgesUseCase` | æ£€æµ‹å¹¶æˆäºˆå¾½ç« ï¼ˆæ ¸å¿ƒï¼‰ | ç§¯åˆ†/å…‘æ¢/ç­¾åˆ°å |
| `AwardBadgeUseCase` | æˆäºˆå•ä¸ªå¾½ç«  | å†…éƒ¨è°ƒç”¨ |
| `GetChildBadgesUseCase` | è·å–å­©å­çš„å¾½ç« åˆ—è¡¨ | æ¡£æ¡ˆé¡µå±•ç¤º |
| `GetBadgeProgressUseCase` | è·å–å¾½ç« è¿›åº¦ | è¿›åº¦å±•ç¤º |
| `CreateBadgeUseCase` | åˆ›å»ºæ–°å¾½ç« å®šä¹‰ | ç®¡ç†åŠŸèƒ½ |
| `UpdateBadgeUseCase` | æ›´æ–°å¾½ç« å®šä¹‰ | ç®¡ç†åŠŸèƒ½ |
| `DeleteBadgeUseCase` | åˆ é™¤å¾½ç« å®šä¹‰ï¼ˆè½¯åˆ é™¤ï¼‰ | ç®¡ç†åŠŸèƒ½ |
| `CheckinUseCase` | ç­¾åˆ°æ“ä½œ | æ¯æ—¥ç­¾åˆ° |

### 5.2 æ ¸å¿ƒç”¨ä¾‹ï¼šæ£€æµ‹å¹¶æˆäºˆå¾½ç« 

```dart
// lib/features/badges/domain/usecases/check_and_award_badges_usecase.dart

/// è§¦å‘ç‚¹æšä¸¾
enum BadgeTriggerPoint {
  afterPointRecordCreated,  // ç§¯åˆ†è®°å½•åˆ›å»ºå
  afterExchangeCompleted,   // å…‘æ¢å®Œæˆå
  afterCheckinCompleted,    // ç­¾åˆ°å®Œæˆå
  manualCheck,              // æ‰‹åŠ¨è§¦å‘æ£€æµ‹
}

class CheckAndAwardBadgesParams {
  final int childId;
  final BadgeTriggerPoint triggerPoint;
  final Map<String, dynamic>? context;
  const CheckAndAwardBadgesParams({...});
}

class BadgeAwardResult {
  final List<BadgeEntity> awardedBadges;
  final int totalBonusPoints;
  const BadgeAwardResult({...});
  bool get hasBadges => awardedBadges.isNotEmpty;
}

class CheckAndAwardBadgesUseCase extends UseCase<CheckAndAwardBadgesParams, BadgeAwardResult> {
  final BadgeDetectionService _detectionService;
  final AwardBadgeUseCase _awardBadgeUseCase;

  @override
  Future<Result<BadgeAwardResult>> execute(CheckAndAwardBadgesParams params) async {
    try {
      // 1. æ ¹æ®è§¦å‘ç‚¹ç¡®å®šè¦æ£€æµ‹çš„å¾½ç« ç±»å‹
      final triggerTypes = _getTriggerTypesForPoint(params.triggerPoint);

      // 2. æ£€æµ‹å¯è·å¾—çš„å¾½ç« 
      final pendingAwards = await _detectionService.detectNewBadges(
        params.childId,
        triggerTypes: triggerTypes,
      );

      if (pendingAwards.isEmpty) {
        return Result.success(const BadgeAwardResult(
          awardedBadges: [],
          totalBonusPoints: 0,
        ));
      }

      // 3. é€ä¸ªæˆäºˆå¾½ç« 
      final awardedBadges = <BadgeEntity>[];
      var totalBonusPoints = 0;

      for (final pending in pendingAwards) {
        final awardResult = await _awardBadgeUseCase.execute(AwardBadgeParams(
          childId: params.childId,
          badge: pending.badge,
          triggerValue: pending.triggerValue,
        ));

        if (awardResult.isSuccess) {
          awardedBadges.add(pending.badge);
          totalBonusPoints += pending.badge.bonusPoints;
        }
      }

      return Result.success(BadgeAwardResult(
        awardedBadges: awardedBadges,
        totalBonusPoints: totalBonusPoints,
      ));
    } catch (e, stackTrace) {
      return Result.failure('å¾½ç« æ£€æµ‹å¤±è´¥', stackTrace: stackTrace);
    }
  }

  List<BadgeTriggerType>? _getTriggerTypesForPoint(BadgeTriggerPoint point) {
    switch (point) {
      case BadgeTriggerPoint.afterPointRecordCreated:
        return [BadgeTriggerType.totalPoints, BadgeTriggerType.pointsEarnedSingle];
      case BadgeTriggerPoint.afterExchangeCompleted:
        return [BadgeTriggerType.exchangeCount];
      case BadgeTriggerPoint.afterCheckinCompleted:
        return [BadgeTriggerType.consecutiveCheckin];
      case BadgeTriggerPoint.manualCheck:
        return null; // æ£€æµ‹æ‰€æœ‰ç±»å‹
    }
  }
}
```

### 5.3 æˆäºˆå¾½ç« ç”¨ä¾‹

```dart
// lib/features/badges/domain/usecases/award_badge_usecase.dart

class AwardBadgeParams {
  final int childId;
  final BadgeEntity badge;
  final int triggerValue;
  final String? note;
  const AwardBadgeParams({...});
}

class AwardBadgeUseCase extends UseCase<AwardBadgeParams, void> {
  final IBadgeAcquisitionRepository _acquisitionRepository;
  final IPointRecordsRepository _pointRecordsRepository;

  @override
  Future<Result<void>> execute(AwardBadgeParams params) async {
    try {
      int? pointRecordId;

      // 1. å¦‚æœ‰å¥–åŠ±ç§¯åˆ†ï¼Œå…ˆåˆ›å»ºç§¯åˆ†è®°å½•
      if (params.badge.bonusPoints > 0) {
        pointRecordId = await _pointRecordsRepository.addRecordAndReturnId(
          childId: params.childId,
          points: params.badge.bonusPoints,
          type: 'earned',
          ruleName: 'å¾½ç« å¥–åŠ±ï¼š${params.badge.name}',
          note: 'è·å¾—å¾½ç« ã€${params.badge.name}ã€‘çš„å¥–åŠ±ç§¯åˆ†',
        );
      }

      // 2. åˆ›å»ºå¾½ç« è·å¾—è®°å½•
      await _acquisitionRepository.create(
        childId: params.childId,
        badgeId: params.badge.id,
        badgeSnapshot: jsonEncode({
          'name': params.badge.name,
          'icon': params.badge.icon,
          'level': params.badge.level,
        }),
        bonusPointsAwarded: params.badge.bonusPoints,
        pointRecordId: pointRecordId,
        triggerValue: params.triggerValue,
        note: params.note,
      );

      return Result.success(null);
    } catch (e, stackTrace) {
      return Result.failure('æˆäºˆå¾½ç« å¤±è´¥', stackTrace: stackTrace);
    }
  }
}
```

---

## å…­ã€ä¸ç°æœ‰æ¨¡å—é›†æˆ

### 6.1 é›†æˆç‚¹è®¾è®¡å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Integration Points                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  ApplyRuleUseCase â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚  (ç§¯åˆ†è§„åˆ™åº”ç”¨)    â”‚          â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â–¼                                â”‚
â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                       â”‚               â”‚
â”‚  â”‚ExchangeRewardUseCaseâ”‚â”€â”€>â”‚ CheckAndAwardBadges â”‚               â”‚
â”‚  â”‚    (å•†å“å…‘æ¢)      â”‚    â”‚      UseCase        â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   (å¾½ç« æ£€æµ‹æˆäºˆ)       â”‚               â”‚
â”‚                         â”‚                       â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚  â”‚  CheckinUseCase  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚  â”‚    (æ¯æ—¥ç­¾åˆ°)     â”‚                                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 ä¿®æ”¹ ApplyRuleUseCaseï¼ˆç§¯åˆ†è§„åˆ™ï¼‰

```dart
// lib/features/rule/domain/usecases/apply_rule_usecase.dartï¼ˆä¿®æ”¹åï¼‰

class ApplyRuleUseCase extends UseCase<ApplyRuleParams, ApplyRuleResult> {
  final IPointRecordsRepository _pointRecordsRepository;
  final CheckAndAwardBadgesUseCase _checkBadgesUseCase;  // æ–°å¢ä¾èµ–

  @override
  Future<Result<ApplyRuleResult>> execute(ApplyRuleParams params) async {
    try {
      // 1. æ·»åŠ ç§¯åˆ†è®°å½•ï¼ˆç°æœ‰é€»è¾‘ï¼‰
      await _pointRecordsRepository.addRecord(
        childId: params.childId,
        points: params.points,
        type: params.type,
        ruleId: params.ruleId,
        ruleName: params.ruleName,
        note: params.note,
      );

      // 2. æ–°å¢ï¼šè§¦å‘å¾½ç« æ£€æµ‹
      BadgeAwardResult? badgeResult;
      if (params.type == 'earned') {
        final checkResult = await _checkBadgesUseCase.execute(
          CheckAndAwardBadgesParams(
            childId: params.childId,
            triggerPoint: BadgeTriggerPoint.afterPointRecordCreated,
            context: {'singlePoints': params.points},
          ),
        );
        badgeResult = checkResult.dataOrNull;
      }

      return Result.success(ApplyRuleResult(
        success: true,
        awardedBadges: badgeResult?.awardedBadges ?? [],
        bonusPoints: badgeResult?.totalBonusPoints ?? 0,
      ));
    } catch (e, stackTrace) {
      return Result.failure('ç§¯åˆ†æ“ä½œå¤±è´¥', stackTrace: stackTrace);
    }
  }
}

/// ç§¯åˆ†æ“ä½œç»“æœï¼ˆæ‰©å±•ï¼‰
class ApplyRuleResult {
  final bool success;
  final List<BadgeEntity> awardedBadges;  // æ–°å¢
  final int bonusPoints;                   // æ–°å¢
  const ApplyRuleResult({...});
  bool get hasBadges => awardedBadges.isNotEmpty;
}
```

### 6.3 ä¿®æ”¹ ExchangeRewardUseCaseï¼ˆå…‘æ¢ï¼‰

```dart
// lib/features/exchange/domain/usecases/exchange_reward_usecase.dartï¼ˆä¿®æ”¹åï¼‰

class ExchangeRewardUseCase extends UseCase<ExchangeRewardParams, ExchangeResult> {
  final IExchangeRepository _exchangeRepository;
  final CheckAndAwardBadgesUseCase _checkBadgesUseCase;  // æ–°å¢ä¾èµ–

  @override
  Future<Result<ExchangeResult>> execute(ExchangeRewardParams params) async {
    try {
      // 1. æ‰§è¡Œå…‘æ¢ï¼ˆç°æœ‰é€»è¾‘ï¼‰
      await _exchangeRepository.exchangeReward(...);

      // 2. æ–°å¢ï¼šè§¦å‘å¾½ç« æ£€æµ‹
      final checkResult = await _checkBadgesUseCase.execute(
        CheckAndAwardBadgesParams(
          childId: params.childId,
          triggerPoint: BadgeTriggerPoint.afterExchangeCompleted,
        ),
      );

      return Result.success(ExchangeResult(
        success: true,
        awardedBadges: checkResult.dataOrNull?.awardedBadges ?? [],
        bonusPoints: checkResult.dataOrNull?.totalBonusPoints ?? 0,
      ));
    } catch (e) {
      return Result.failure('å…‘æ¢å¤±è´¥');
    }
  }
}
```

---

## ä¸ƒã€Provider æ³¨å†Œ

```dart
// lib/features/badges/providers/badge_providers.dart

/// å¾½ç« ä»“åº“ Provider
final badgeRepositoryProvider = Provider<BadgeRepository>((ref) {
  return BadgeRepository(ref.watch(databaseProvider));
});

/// å¾½ç« è·å¾—è®°å½•ä»“åº“ Provider
final badgeAcquisitionRepositoryProvider = Provider<BadgeAcquisitionRepository>((ref) {
  return BadgeAcquisitionRepository(ref.watch(databaseProvider));
});

/// è¯„ä¼°å™¨å·¥å‚ Provider
final badgeEvaluatorFactoryProvider = Provider<BadgeEvaluatorFactory>((ref) {
  final factory = BadgeEvaluatorFactory();
  factory.register(TotalPointsEvaluator(ref.watch(pointRecordsRepositoryProvider)));
  factory.register(ConsecutiveCheckinEvaluator(ref.watch(checkinRepositoryProvider)));
  factory.register(ExchangeCountEvaluator(ref.watch(exchangeRepositoryProvider)));
  factory.register(SinglePointsEvaluator());
  return factory;
});

/// å¾½ç« æ£€æµ‹æœåŠ¡ Provider
final badgeDetectionServiceProvider = Provider<BadgeDetectionService>((ref) {
  return BadgeDetectionService(
    ref.watch(badgeRepositoryProvider),
    ref.watch(badgeAcquisitionRepositoryProvider),
    ref.watch(badgeEvaluatorFactoryProvider),
  );
});

/// æ£€æµ‹å¹¶æˆäºˆå¾½ç« ç”¨ä¾‹ Provider
final checkAndAwardBadgesUseCaseProvider = Provider<CheckAndAwardBadgesUseCase>((ref) {
  return CheckAndAwardBadgesUseCase(
    ref.watch(badgeDetectionServiceProvider),
    ref.watch(awardBadgeUseCaseProvider),
  );
});

/// å­©å­å¾½ç« åˆ—è¡¨ Provider
final childBadgesProvider = FutureProvider.family<List<ChildBadgeDisplay>, int>((ref, childId) async {
  final useCase = ref.watch(getChildBadgesUseCaseProvider);
  final result = await useCase.execute(GetChildBadgesParams(childId: childId));
  return result.dataOrNull ?? [];
});

/// å­©å­å·²è·å¾—å¾½ç«  Provider
final childAcquiredBadgesProvider = FutureProvider.family<List<ChildBadgeDisplay>, int>((ref, childId) async {
  final useCase = ref.watch(getChildBadgesUseCaseProvider);
  final result = await useCase.execute(GetChildBadgesParams(
    childId: childId,
    acquiredOnly: true,
  ));
  return result.dataOrNull ?? [];
});
```

---

## å…«ã€ç›®å½•ç»“æ„

```
lib/features/badges/
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ badge_repository.dart              # å¾½ç« å®šä¹‰ä»“åº“å®ç°
â”‚   â”œâ”€â”€ badge_acquisition_repository.dart  # å¾½ç« è·å¾—è®°å½•ä»“åº“å®ç°
â”‚   â””â”€â”€ checkin_repository.dart            # ç­¾åˆ°è®°å½•ä»“åº“å®ç°
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ badge_entity.dart              # å¾½ç« å®ä½“
â”‚   â”‚   â”œâ”€â”€ badge_acquisition_entity.dart  # å¾½ç« è·å¾—è®°å½•å®ä½“
â”‚   â”‚   â””â”€â”€ checkin_entity.dart            # ç­¾åˆ°è®°å½•å®ä½“
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ i_badge_repository.dart        # å¾½ç« ä»“åº“æ¥å£
â”‚   â”‚   â”œâ”€â”€ i_badge_acquisition_repository.dart  # è·å¾—è®°å½•ä»“åº“æ¥å£
â”‚   â”‚   â””â”€â”€ i_checkin_repository.dart      # ç­¾åˆ°ä»“åº“æ¥å£
â”‚   â”œâ”€â”€ evaluators/
â”‚   â”‚   â”œâ”€â”€ badge_condition_evaluator.dart     # è¯„ä¼°å™¨æ¥å£
â”‚   â”‚   â”œâ”€â”€ badge_evaluator_factory.dart       # è¯„ä¼°å™¨å·¥å‚
â”‚   â”‚   â”œâ”€â”€ total_points_evaluator.dart        # ç´¯è®¡ç§¯åˆ†è¯„ä¼°å™¨
â”‚   â”‚   â”œâ”€â”€ consecutive_checkin_evaluator.dart # è¿ç»­ç­¾åˆ°è¯„ä¼°å™¨
â”‚   â”‚   â”œâ”€â”€ exchange_count_evaluator.dart      # å…‘æ¢æ¬¡æ•°è¯„ä¼°å™¨
â”‚   â”‚   â””â”€â”€ single_points_evaluator.dart       # å•æ¬¡ç§¯åˆ†è¯„ä¼°å™¨
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ badge_detection_service.dart   # å¾½ç« æ£€æµ‹æœåŠ¡
â”‚   â”‚   â””â”€â”€ badge_trigger_points.dart      # è§¦å‘ç‚¹æšä¸¾
â”‚   â””â”€â”€ usecases/
â”‚       â”œâ”€â”€ check_and_award_badges_usecase.dart  # æ£€æµ‹å¹¶æˆäºˆå¾½ç« 
â”‚       â”œâ”€â”€ award_badge_usecase.dart             # æˆäºˆå¾½ç« 
â”‚       â”œâ”€â”€ get_child_badges_usecase.dart        # è·å–å­©å­å¾½ç« 
â”‚       â”œâ”€â”€ get_badge_progress_usecase.dart      # è·å–å¾½ç« è¿›åº¦
â”‚       â”œâ”€â”€ create_badge_usecase.dart            # åˆ›å»ºå¾½ç« 
â”‚       â”œâ”€â”€ update_badge_usecase.dart            # æ›´æ–°å¾½ç« 
â”‚       â”œâ”€â”€ delete_badge_usecase.dart            # åˆ é™¤å¾½ç« 
â”‚       â””â”€â”€ checkin_usecase.dart                 # ç­¾åˆ°ç”¨ä¾‹
â”œâ”€â”€ presentation/
â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ badge_gallery_screen.dart      # å¾½ç« å±•ç¤ºé¡µ
â”‚   â”‚   â”œâ”€â”€ badge_detail_screen.dart       # å¾½ç« è¯¦æƒ…é¡µ
â”‚   â”‚   â””â”€â”€ badge_manage_screen.dart       # å¾½ç« ç®¡ç†é¡µ
â”‚   â””â”€â”€ widgets/
â”‚       â”œâ”€â”€ badge_card.dart                # å¾½ç« å¡ç‰‡ç»„ä»¶
â”‚       â”œâ”€â”€ badge_grid.dart                # å¾½ç« ç½‘æ ¼ç»„ä»¶
â”‚       â”œâ”€â”€ badge_progress_indicator.dart  # è¿›åº¦æŒ‡ç¤ºå™¨
â”‚       â””â”€â”€ badge_award_dialog.dart        # è·å¾—å¾½ç« å¼¹çª—
â””â”€â”€ providers/
    â””â”€â”€ badge_providers.dart               # Riverpod Providers
```

---

## ä¹ã€é¢„ç½®ç³»ç»Ÿå¾½ç« 

| å¾½ç« åç§° | ç±»å‹ | é˜ˆå€¼ | å¥–åŠ±ç§¯åˆ† | ç­‰çº§ | å›¾æ ‡ |
|----------|------|------|----------|------|------|
| åˆéœ²é”‹èŠ’ | ç´¯è®¡ç§¯åˆ† | 100 | 10 | 1 | badge_bronze_star |
| å°æœ‰æˆå°± | ç´¯è®¡ç§¯åˆ† | 500 | 30 | 2 | badge_silver_star |
| æ˜Ÿå…‰ç’€ç’¨ | ç´¯è®¡ç§¯åˆ† | 1000 | 50 | 3 | badge_gold_star |
| æ»¡å¤©æ˜Ÿæ–— | ç´¯è®¡ç§¯åˆ† | 5000 | 100 | 4 | badge_diamond_star |
| åšæŒä¸€å‘¨ | è¿ç»­ç­¾åˆ° | 7 | 20 | 1 | badge_calendar_week |
| åšæŒä¸€æœˆ | è¿ç»­ç­¾åˆ° | 30 | 50 | 2 | badge_calendar_month |
| ä¹ æƒ¯å…»æˆ | è¿ç»­ç­¾åˆ° | 100 | 100 | 3 | badge_calendar_hundred |
| åˆæ¬¡å°é²œ | å…‘æ¢æ¬¡æ•° | 1 | 5 | 1 | badge_gift_first |
| è´­ç‰©è¾¾äºº | å…‘æ¢æ¬¡æ•° | 10 | 30 | 2 | badge_gift_master |
| å¤§æœ‰ä½œä¸º | å•æ¬¡ç§¯åˆ† | 50 | 20 | 1 | badge_lightning |

---

## åã€UI è®¾è®¡è¦ç‚¹

### 10.1 å¾½ç« å±•ç¤ºä½ç½®
- **å­©å­æ¡£æ¡ˆé¡µ**ï¼šå·²è·å¾—å¾½ç« ç½‘æ ¼å±•ç¤º
- **è®¾ç½®é¡µ**ï¼šå¾½ç« ç®¡ç†å…¥å£
- **è·å¾—æ—¶**ï¼šå¼¹çª—åŠ¨ç”»é€šçŸ¥ + å¥–åŠ±ç§¯åˆ†å±•ç¤º

### 10.2 å¾½ç« å¡ç‰‡çŠ¶æ€
- **å·²è·å¾—**ï¼šå½©è‰²å›¾æ ‡ + è·å¾—æ—¶é—´ + å¥–åŠ±ç§¯åˆ†
- **æœªè·å¾—**ï¼šç°è‰²å›¾æ ‡ + è¿›åº¦æ¡ + è§£é”æ¡ä»¶
- **é”å®š**ï¼šæ˜¾ç¤ºè§£é”æ¡ä»¶æè¿°

### 10.3 è·å¾—å¼¹çª—è®¾è®¡
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                â”‚
â”‚         ğŸ† æ­å–œè·å¾—å¾½ç« !        â”‚
â”‚                                â”‚
â”‚        â­ æ˜Ÿå…‰ç’€ç’¨ â­           â”‚
â”‚     ç´¯è®¡è·å¾— 1000 é¢—æ˜Ÿæ˜Ÿ        â”‚
â”‚                                â”‚
â”‚      ğŸ å¥–åŠ±: +50 æ˜Ÿæ˜Ÿ          â”‚
â”‚                                â”‚
â”‚         [ å¤ªæ£’äº†! ]            â”‚
â”‚                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## åä¸€ã€å®æ–½è®¡åˆ’

| é˜¶æ®µ | å†…å®¹ | ä¼˜å…ˆçº§ | é¢„ä¼°å·¥ä½œé‡ |
|------|------|--------|-----------|
| **Phase 1** | æ•°æ®åº“è¡¨ + å®ä½“å®šä¹‰ + ä»“åº“å±‚ | P0 | 1å¤© |
| **Phase 2** | è¯„ä¼°å™¨å¼•æ“ + æ£€æµ‹æœåŠ¡ | P0 | 1å¤© |
| **Phase 3** | ç”¨ä¾‹å®ç° + Provider æ³¨å†Œ | P0 | 1å¤© |
| **Phase 4** | é›†æˆç°æœ‰æ¨¡å—ï¼ˆç§¯åˆ†/å…‘æ¢ï¼‰ | P0 | 0.5å¤© |
| **Phase 5** | UI é¡µé¢ï¼ˆå±•ç¤º/å¼¹çª—ï¼‰ | P1 | 1.5å¤© |
| **Phase 6** | ç­¾åˆ°åŠŸèƒ½ + è¿ç»­ç­¾åˆ°å¾½ç«  | P2 | 1å¤© |
| **Phase 7** | å¾½ç« ç®¡ç†é¡µï¼ˆè‡ªå®šä¹‰å¾½ç« ï¼‰ | P2 | 1å¤© |

---

## åäºŒã€è®¾è®¡ä¼˜åŠ¿æ€»ç»“

| è®¾è®¡ç‚¹ | æ–¹æ¡ˆ | ä¼˜åŠ¿ |
|--------|------|------|
| è§¦å‘æ¡ä»¶ | ç­–ç•¥æ¨¡å¼ + æšä¸¾ + JSONæ‰©å±• | ç±»å‹å®‰å…¨ï¼Œæ˜“äºæ‰©å±•æ–°æ¡ä»¶ç±»å‹ |
| æ£€æµ‹æ—¶æœº | äº‹ä»¶é©±åŠ¨ï¼ˆåç½®è§¦å‘ï¼‰ | ä¸ä¸šåŠ¡è§£è€¦ï¼Œä¸é˜»å¡ä¸»æµç¨‹ |
| æ¡ä»¶è¯„ä¼° | è¯„ä¼°å™¨å·¥å‚ | å¼€é—­åŸåˆ™ï¼Œæ–°å¢ç±»å‹æ— éœ€ä¿®æ”¹æ ¸å¿ƒä»£ç  |
| æ•°æ®å¿«ç…§ | è·å¾—è®°å½•å­˜å‚¨å¾½ç« å¿«ç…§ | å†å²æ•°æ®ä¸å—å¾½ç« ä¿®æ”¹å½±å“ |
| ç§¯åˆ†å¥–åŠ± | å¤ç”¨ç°æœ‰ç§¯åˆ†æµæ°´ | ç»Ÿä¸€ç§¯åˆ†ç®¡ç†ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§ |

---

## åä¸‰ã€æ‰©å±•æ€§é¢„ç•™

1. **æ–°å¢è§¦å‘ç±»å‹**ï¼šåªéœ€å®ç° `IBadgeConditionEvaluator` æ¥å£å¹¶æ³¨å†Œåˆ°å·¥å‚
2. **å¤æ‚æ¡ä»¶**ï¼š`triggerConfig` JSON å­—æ®µæ”¯æŒä»»æ„å¤æ‚é…ç½®
3. **è‡ªå®šä¹‰å¾½ç« **ï¼š`isSystem=false` æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰å¾½ç« 
4. **å¾½ç« ç­‰çº§**ï¼š`level` å­—æ®µæ”¯æŒåŒç³»åˆ—å¾½ç« çš„é€’è¿›å±•ç¤º
5. **å¤šæ¡ä»¶ç»„åˆ**ï¼šå¯æ‰©å±•ä¸º `AND/OR` ç»„åˆæ¡ä»¶ï¼ˆé€šè¿‡ custom ç±»å‹å®ç°ï¼‰

---

## åå››ã€æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼šå¾½ç« æ£€æµ‹åº”åœ¨ä¸»äº‹åŠ¡å¤–å¼‚æ­¥æ‰§è¡Œï¼Œé¿å…å½±å“ä¸»ä¸šåŠ¡å“åº”æ—¶é—´
2. **å¹‚ç­‰æ€§**ï¼šå·²è·å¾—å¾½ç« ä¸ä¼šé‡å¤æˆäºˆï¼ˆé€šè¿‡ `acquiredBadgeIds` é›†åˆæ£€æŸ¥ï¼‰
3. **è½¯åˆ é™¤**ï¼šæ‰€æœ‰åˆ é™¤æ“ä½œéƒ½æ˜¯è½¯åˆ é™¤ï¼Œä¿æŠ¤å†å²æ•°æ®å®Œæ•´æ€§
4. **å¿«ç…§å­˜å‚¨**ï¼šè·å¾—è®°å½•å­˜å‚¨å¾½ç« å¿«ç…§ï¼Œé˜²æ­¢ä¿®æ”¹åä¸¢å¤±ä¸Šä¸‹æ–‡
5. **å›½é™…åŒ–**ï¼šå¾½ç« åç§°å’Œæè¿°éœ€è¦æ”¯æŒå¤šè¯­è¨€ï¼ˆé€šè¿‡ l10n å¤„ç†ï¼‰
